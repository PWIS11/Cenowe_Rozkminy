---
title: "Analiza cen mieszkań w Polsce"
date: "`r Sys.Date()`"
author: "Piotr Wiśniewski - lider zespołu, Izabela Reszka, Klaudia Woźniak"
output:
  html_document:
    theme: cerulean
    highlight: tango
    highlight_color: "goldenrod"
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
## Global options
knitr::opts_chunk$set(cache = TRUE)
# Instalacja Pakietów
if (!requireNamespace("httr", quietly = TRUE)) install.packages("httr")
if (!requireNamespace("jsonlite", quietly = TRUE)) install.packages("jsonlite")
if (!requireNamespace("tidygeocoder", quietly = TRUE)) install.packages("tidygeocoder")
if (!requireNamespace("dplyr", quietly = TRUE)) install.packages("dplyr")
if (!requireNamespace("sf", quietly = TRUE)) install.packages("sf")
if (!requireNamespace("ggplot2", quietly = TRUE)) install.packages("ggplot2")
if (!requireNamespace("scales", quietly = TRUE)) install.packages("scales")
if (!requireNamespace("tidyverse", quietly = TRUE)) install.packages("tidyverse")
if (!requireNamespace("naniar", quietly = TRUE)) install.packages("naniar")
if (!requireNamespace("VIM", quietly = TRUE)) install.packages("VIM")
if (!requireNamespace("outliers", quietly = TRUE)) install.packages("outliers")
if (!requireNamespace("caret", quietly = TRUE)) install.packages("caret")
if (!requireNamespace("mice", quietly = TRUE)) install.packages("mice")
if (!requireNamespace("gridExtra", quietly = TRUE)) install.packages("gridExtra")
if (!requireNamespace("dlookr", quietly = TRUE)) install.packages("dlookr")

```

```{r libraries, include=FALSE}
library(httr)
library(jsonlite)
library(tidygeocoder)
library(dplyr)
library(sf)
library(ggplot2)
library(scales)
library(tidyverse)
library(naniar)
library(VIM)
library(outliers)
library(caret)
library(mice)
library(gridExtra)
library(dlookr)
```

# **Cel projektu**

Celem naszego projektu jest analiza cen mieszkań w największych miastach Polski, uwzględniając różnorodne czynniki, które mogą wpływać na wartość nieruchomości. Wykorzystamy metody analizy danych, aby odpowiedzieć na kluczowe pytania, takie jak:

-   *Od czego zależy cena mieszkań?*

-   *Jakie różnice w cenach występują pomiędzy miastami?*

-   *Czy odległość od centrum lub interesujących miejsc (POI) ma znaczenie dla wartości nieruchomości?*

-   *Które cechy mieszkań (np. liczba pokoi, stan, udogodnienia) są najbardziej cenione?*

## **Analizy w projekcie**

Planujemy zastosowanie narzędzi analizy danych oraz wizualizacji, aby lepiej zrozumieć rynek nieruchomości w Polsce. Nasze analizy obejmą:

-   Badanie zależności między cechami mieszkań (takimi jak lokalizacja, powierzchnia, liczba pokoi) a ich ceną.

-   Porównanie cen nieruchomości pomiędzy największymi polskimi miastami, w celu wykazania kluczowych różnic regionalnych.

-   Modelowanie predykcyjne, które pozwoli oszacować cenę mieszkań na podstawie wybranych zmiennych, takich jak odległość od centrum czy stan mieszkania.

-   Wykorzystanie interaktywnych wizualizacji, takich jak mapy i wykresy, aby przedstawić wyniki w przystępny sposób.

### **Hipotezy i oczekiwane wyniki**

1.  **Odległość od centrum miasta:** Zakładamy, że im bliżej centrum, tym wyższa cena mieszkań, choć siła tego wpływu może różnić się w zależności od miasta.

2.  **Cechy nieruchomości:** Udogodnienia takie jak balkon, winda czy miejsce parkingowe znacząco podnoszą wartość mieszkań, zwłaszcza w dużych miastach.

3.  **Różnice regionalne:** Miasta o wyższym poziomie urbanizacji i rozwiniętej infrastrukturze (np. Warszawa, Kraków, Wrocław) mają wyższe ceny mieszkań w porównaniu do mniejszych miejscowości.

4.  **Rok budowy:** Starsze mieszkania, wymagające remontu, są z reguły tańsze, chyba że znajdują się w prestiżowych lokalizacjach.

Podsumowując, oczekujemy, że nasze analizy wskażą najważniejsze czynniki wpływające na ceny mieszkań oraz umożliwią stworzenie użytecznych modeli predykcyjnych, które mogą wspierać decyzje zakupowe lub inwestycyjne.

5.  Czy wiek mieszkania ma taki sam wpływ na jego cenę w centrum jak na obrzeżach?

## **Opis danych**

Zbiór danych pochodzi z ofert sprzedaży i wynajmu mieszkań z 15 największych polskich miast, zgromadzonych w czerwcu 2024 roku. Dane te obejmują szerokie spektrum cech nieruchomości oraz dodatkowe informacje z Open Street Map, które pozwalają uwzględnić kontekst sąsiedztwa mieszkań.

**Miasta w zbiorze danych:** Warszawa, Łódź, Kraków, Wrocław, Poznań, Gdańsk, Szczecin, Bydgoszcz, Lublin, Katowice, Białystok, Częstochowa.

**Główne pola w zbiorze danych:**

-   ***Lokalizacja i charakterystyka nieruchomości:***

    -   Miasto, typ budynku, wielkość w metrach kwadratowych, liczba pokoi, piętro, rok budowy.

-   ***Informacje kontekstowe:***

    -   Odległość od centrum miasta, liczba interesujących punktów w promieniu 500 metrów (np. szkoły, apteki, restauracje) oraz odległość do najbliższego punktu.

-   ***Cechy nieruchomości:***

    -   Stan mieszkania, rodzaj własności, obecność udogodnień (np. winda, balkon, miejsce parkingowe, ochrona).

-   ***Cena ofertowa:***

    -   Cena sprzedaży lub miesięczny czynsz.

## **Dane dodatkowe**

## **Znaczenie projektu**

Rynek nieruchomości jest dynamiczny i podlega wpływowi wielu czynników, takich jak lokalizacja, liczba pokoi, dostępność udogodnień czy bliskość kluczowych miejsc. Analiza tych danych pozwoli lepiej zrozumieć mechanizmy kształtowania się cen mieszkań oraz stworzyć narzędzia wspomagające decyzje zakupowe i inwestycyjne.

```{r wstepna_obrobka_danych, echo=FALSE}
dane <- read.csv("apartments_pl_2024_06.csv", sep = ",", header = TRUE)

# Zmiana id na liczby rosnące, zaczynające się od cyfry 1
dane$id <- 1:nrow(dane)

# Zamiana pustych ciągów na NA
dane[dane == ""] <- NA
```

# **Data wrangling**

## **Obserwacje brakujące**

Klasyfikacja braków danych w zbiorze:

-   **MCAR (Missing Completely At Random)**: Braki w kolumnach takich jak hasElevator i collegeDistance są losowe i wynikają z technicznych pominięć w zbieraniu danych.

-   **MAR (Missing At Random)**: Braki w kolumnach condition, buildingMaterial, oraz floor wynikają z powiązań między zmiennymi, np. type i floorCount.

-   **MNAR (Missing Not At Random)**: Braki w type mogą wynikać z mechanizmu niechęci podawania wartości (np. dla mieszkań luksusowych).

**Może opis jak zamierzamy je badać i dlaczego ? Typu - zdecydowaliśmy się wykonać wykres taki i taki aby zbadać coś tam**

```{r obserwacje_brakujace_wykresy, echo=FALSE, comment=FALSE}
missing_summary <- miss_var_summary(dane)

ggplot(missing_summary, aes(x = reorder(variable, -pct_miss), y = pct_miss)) +
  geom_bar(stat = "identity", fill = "plum2") +
  coord_flip() +
  labs(title = "Procent brakujących wartości w kolumnach",
       x = "Zmienne",
       y = "Procent braków (%)") +
  theme_minimal()
```

```{r obserwacje_brakujace_wykresy_2, echo=FALSE}
vismiss <- vis_miss(dane) +
  labs(
    title = "Braki danych w zbiorze",
    x = "Zmienne",
    y = "Obserwacje"
  ) +
  theme_minimal(base_size = 10) + 
  scale_fill_manual(values = c("lightyellow", "orchid3"),
                    name = "Status danych",
                    labels = c("Dane obecne", "Braki danych")) +
  theme(
    plot.title = element_text(hjust = 0.5),
    axis.text.x = element_text(angle = 45, hjust = 0.2)
  )
print(vismiss)
```

Analiza brakujących danych wskazuje, że kolumny w zbiorze można podzielić na kilka grup pod względem liczby braków:

-   **Bardzo duża liczba braków:** condition (74.0%) i buildingMaterial (40.9%). Ze względu na ich wysoką niekompletność zdecydowaliśmy się usunąć kolumnę condition, a dla buildingMaterial zastosujemy imputację najczęstszą wartością.

-   **Umiarkowana liczba braków:** type (20.5%), floor (16.6%), buildYear (15.7%). Uzupełnimy brakujące wartości odpowiednio metodą najczęstszej wartości dla zmiennych kategorycznych (type) oraz medianą dla zmiennych liczbowych (floor, buildYear).

-   **Niewielka liczba braków:** Kolumny takie jak hasElevator (4.46%) czy collegeDistance (2.72%) zostaną uzupełnione odpowiednio modą i medianą.

-   **Bardzo mała liczba braków:** Pozostałe kolumny z mniej niż 1% braków zostaną imputowane prostymi metodami (medianą lub najczęstszą wartością).

-   **Kolumny bez braków:** Pozostałe zmienne, takie jak price, squareMeters czy rooms, są kompletne i nie wymagają dodatkowych działań.

```{r wzorce_brakow}
aggr(dane, col = c("lightyellow", "orchid3"), numbers = TRUE, sortVars = TRUE,
     labels = names(data), cex.axis = 0.7, gap = 3, ylab = c("Procent braków", "Wzorce braków"))
```

### Imputacja medianą oraz modą

```{r Zastąpienie_braków_medianą_i_najczęstszą_wartością}
################################################################################

dane$floor<-imputate_na(dane, floor, method = "median")
dane$buildYear<-imputate_na(dane, buildYear, method = "median")
dane$collegeDistance<-imputate_na(dane, collegeDistance, method = "median")
dane$schoolDistance<-imputate_na(dane, schoolDistance, method = "median")
dane$pharmacyDistance<-imputate_na(dane, pharmacyDistance, method = "median")
dane$kindergartenDistance<-imputate_na(dane, kindergartenDistance, method = "median")
dane$clinicDistance<-imputate_na(dane, clinicDistance, method = "median")
dane$postOfficeDistance<-imputate_na(dane, postOfficeDistance, method = "median")
dane$restaurantDistance<-imputate_na(dane, restaurantDistance, method = "median")

################################################################################

#table(na.omit(dane$type)) SPRAWDZENIE CZĘSTOSCI WYSTĘPOWANIA
#table(na.omit(dane$buildingMaterial)) SPRAWDZENIE CZĘSTOSCI WYSTĘPOWANIA
#table(na.omit(dane$hasElevator))

dane$type[is.na(dane$type)] <- "blockOfFlats"
dane$buildingMaterial[is.na(dane$buildingMaterial)] <- "brick"
dane$hasElevator[is.na(dane$hasElevator)] <- "yes"

dane$type <- factor(dane$type)
dane$buildingMaterial <- factor(dane$buildingMaterial)
dane$hasElevator <- factor(dane$hasElevator)

#dane$buildingMaterial<-imputate_na(dane, buildingMaterial, method = "mode") -----> wyskakuje błąd
################################################################################
dane$condition <- NA
dane <- subset(dane, select = -condition)
################################################################################
```

```{r dodatkowe_kolumny1}
# Dodanie kolumny z ceną za metr kwadratowy
dane$pricePerSquareMeter <- dane$price / dane$squareMeters

# Dodanie kolumny z wiekiem mieszkania
currentYear <- format(Sys.Date(), "%Y")
dane$buildingAge <- ifelse(is.na(dane$buildYear), NA, as.numeric(currentYear) - dane$buildYear)

# Tworzenie kategorii wieku mieszkań
dane$buildingCategory <- cut(
  dane$buildingAge,
  breaks = c(-Inf, 5, 20, 50, Inf),
  labels = c("Nowe", "Średnie", "Stare", "Zabytkowe"),
  right = FALSE
)

# Konwersja na character, dodanie "Nieokreślone", a następnie ponownie na factor
dane$buildingCategory <- as.character(dane$buildingCategory)
dane$buildingCategory[is.na(dane$buildingAge)] <- "Nieokreślone"
dane$buildingCategory <- factor(dane$buildingCategory, levels = c("Nowe", "Średnie", "Stare", "Zabytkowe"))

#table(na.omit(dane$buildingCategory))
#sprawdzić czy nieokreślone ma dalej sens po uzupełnieniu danych
# Sprawdzenie wyników
#table(dane$buildingCategory)
```

## **Obserwacje odstające**

Do analizy obserwacji odstających decydowaliśmy się użyć **wykresów pudełkowych**, ponieważ są one prostym i skutecznym narzędziem wizualizacyjnym, które pozwala szybko zidentyfikować wartości odstające. Dzięki nim poznamy wartości minimalne, maksymalne, mediane, kwartyle oraz ewentualne wartości wykraczające poza tzw. *wąsy*, czyli zakres między pierwszym a trzecim kwartylem powiększony. Każda z analizowanych zmiennych została przedstawiona na osobnym wykresie pudełkowym, co pozwala dokładnie przyjrzeć się rozkładowi poszczególnych cech, takich jak powierzchnia mieszkania, cena, cena za metr kwadratowy czy odległości od różnych punktów użyteczności publicznej. Dzięki temu można szybko zidentyfikować zmienne, które mogą zawierać nietypowe wartości i potencjalnie wpłynąć na dalsze analizy lub modelowanie danych.

Dodatkowo, aby potwierdzić statystycznie obecność obserwacji odstających zastosowaliśmy metodę Z-score oraz zbadaliśmy czy rozkład danych jest zbliżony do rozkładu normalnego.

-   Metoda **Z-score**, polega na identyfikowaniu obserwacji odstających na podstawie odchylenia standardowego od średniej. Wyraża się wzorem: $$
         Z = \frac{x - \bar{x}}{\sigma}
         $$ $x$: wartość obserwacji\
    $\overline{x}$: średnia dla danej zmiennej\
    $\sigma$: odchylenie standardowe.

**Skośność** jest statystyką umożliwiającą porównanie rozkładu analizowanej zmiennej z hipotetycznym rozkładem normalnym. Wskazuje na rozbieżności pomiędzy wartością średnią, a centrum danego rozkładu. Wyraża się wzorem:

$$\tilde{\mu}_3 = \frac{\sum_{i}^{N} (X_i - \bar{X})^3}{(N - 1) \cdot \sigma^3}$$

-   $\tilde{\mu}_3$ = skośność
-   $N$ = liczba zmiennych w rozkładzie
-   $X_i$ = losowa zmienna
-   $\bar{X}$ = średnia rozkładu
-   $\sigma$ = odchylenie standardowe.

Interpretacja jest następująca:

-   Rozkład prawoskośny -- skośność jest dodatnia, prawe ramię rozkładu jest wydłużone, wyniki poniżej średniej są przeważające w badanej próbce.

-   Rozkład symetryczny -- skośność wynosi 0, ogony rozkładu są identyczne w obu kierunkach. Jeśli znormalizowana kurtoza wynosi 0, rozkład jest zbliżony do rozkładu normalnego.

-   Rozkład lewoskośny -- skośność jest ujemna, lewe ramię rozkładu jest wydłużone, większość obserwacji w próbie ma wartości powyżej średniej.

### Wykresy pudełkowe

```{r zamiana_na_numeryczne, echo=FALSE}
dane$buildingAge <- as.numeric(dane$buildingAge)
dane$latitude <- as.numeric(dane$latitude)
dane$longitude <- as.numeric(dane$longitude)
dane$centreDistance <- as.numeric(dane$centreDistance)
dane$schoolDistance <- as.numeric(dane$schoolDistance)
dane$clinicDistance <- as.numeric(dane$clinicDistance)
dane$postOfficeDistance <- as.numeric(dane$postOfficeDistance)
dane$kindergartenDistance <- as.numeric(dane$kindergartenDistance)
dane$collegeDistance <- as.numeric(dane$collegeDistance)
dane$restaurantDistance <- as.numeric(dane$restaurantDistance)
dane$pharmacyDistance <- as.numeric(dane$pharmacyDistance)
dane$floorCount <- as.numeric(dane$floorCount)
```

```{r boxplot_odst, fig.height=10,fig.width=10, echo=FALSE}
par(mfrow = c(3, 3))  # 3 wiersze, 4 kolumny
ploti1 <- boxplot(dane$squareMeters, main = "Square Meters", col = "skyblue")
ploti2 <- boxplot(dane$price, main = "Price", col = "plum")
ploti3 <- boxplot(dane$pricePerSquareMeter, main = "pricePerSquareMeter", col = "peachpuff")
ploti4 <- boxplot(dane$rooms, main = "Rooms", col = "palegreen2")
ploti5 <- boxplot(dane$floor, main = "Floors", col = "powderblue")
ploti6 <- boxplot(dane$floorCount, main = "FloorCount", col = "thistle3")
ploti7 <- boxplot(dane$buildingAge, main = "BuildingAge", col = "salmon")
ploti10 <- boxplot(dane$centreDistance, main = "CentreDistance", col = "pink4")
ploti11 <- boxplot(dane$schoolDistance, main = "SchoolDistance", col = "pink")
ploti12 <- boxplot(dane$clinicDistance, main = "ClinicDistance", col = "orange")
ploti13 <- boxplot(dane$postOfficeDistance, main = "PostOfficeDistance", col = "coral")
ploti14 <- boxplot(dane$kindergartenDistance, main = "KindergardenDistance", col = "lavender")
ploti15 <- boxplot(dane$restaurantDistance, main = "RestaurantDistance", col = "khaki")
ploti16 <- boxplot(dane$collegeDistance, main = "CollegeDistance", col = "indianred")
ploti17 <- boxplot(dane$pharmacyDistance, main = "PharmacyDistance", col = "lavenderblush2")
par(mfrow = c(1, 1)) 
```

Tu pojawi się opis :) **ZAPYTAC SIE CZEMU JAK GENERUJE SIE HTML ROBI SIE TAKA PRZERWA MIEDZY OPISEM A WYKRESAMI**

### Z-score oraz skośność

```{r z-score, echo = FALSE}
# length(which(abs(scale(dane$price)) > 3))
# length(which(abs(scale(dane$squareMeters)) > 3))
# length(which(abs(scale(dane$pricePerSquareMeter)) > 3))
# length(which(abs(scale(dane$rooms)) > 3))
# length(which(abs(scale(dane$floor)) > 3))
# length(which(abs(scale(dane$floorCount)) > 3))
# length(which(abs(scale(dane$buildingAge)) > 3))
# length(which(abs(scale(dane$centreDistance)) > 3))
# length(which(abs(scale(dane$schoolDistance)) > 3))
# length(which(abs(scale(dane$clinicDistance)) > 3))
# length(which(abs(scale(dane$postOfficeDistance)) > 3))
# length(which(abs(scale(dane$kindergartenDistance)) > 3))
# length(which(abs(scale(dane$restaurantDistance)) > 3))
# length(which(abs(scale(dane$collegeDistance)) > 3))
# length(which(abs(scale(dane$pharmacyDistance)) > 3))
# length(which(abs(scale(dane$poiCount)) > 3))
# length(which(abs(scale(dane$buildYear)) > 3))
```

```{r skosnosc, echo = FALSE, eval = TRUE}
# hist(dane$squareMeters)
# hist(dane$rooms)
# hist(dane$floor)
# hist(dane$floorCount)
# hist(dane$buildYear)
# hist(dane$centreDistance)
# hist(dane$poiCount)
# hist(dane$schoolDistance)
# hist(dane$clinicDistance)
# hist(dane$postOfficeDistance)
# hist(dane$kindergartenDistance)
# hist(dane$restaurantDistance)
# hist(dane$collegeDistance)
# hist(dane$pharmacyDistance)
# hist(dane$buildingAge)
```

```{r tabela_wynikow, eval=TRUE, echo=FALSE, results='asis'}
skewness_values <- c(find_skewness(dane, value=TRUE, thres=0.1))
z_score_outliers <- c(
  price = 478, squareMeters = 365, pricePerSquareMeter = 16, 
  rooms = 141, floor = 371, floorCount = 388, buildingAge = 142, 
  centreDistance = 115, schoolDistance = 410, clinicDistance = 450, 
  postOfficeDistance = 401, kindergartenDistance = 409, 
  restaurantDistance = 388, collegeDistance = 188, pharmacyDistance = 410, 
  poiCount = 568, buildYear = 142
)

variable_names <- intersect(names(skewness_values), names(z_score_outliers))

results_table <- data.frame(
  Z_Score = z_score_outliers[variable_names],
  Skewness = skewness_values[variable_names]
)

Interpretacje <- c(
  squareMeters = "Duża liczba wartości odstających i umiarkowana skośność prawostronna – zalecana transformacja logarytmiczna.",
  rooms = "Stosunkowo niewiele wartości odstających i umiarkowana skośność – transformacja nie jest konieczna.",
  price = "Wysoka liczba wartości odstających i umiarkowana skośność sugerują konieczność transformacji (np. logarytmowej).",
  floor = "Duża liczba wartości odstających i wysoka skośność prawostronna – zalecana transformacja, np. logarytmiczna.",
  floorCount = "Duża liczba wartości odstających i umiarkowana skośność prawostronna – warto rozważyć transformację.",
  buildYear = "Niewielka liczba wartości odstających, ale ujemna skośność – może wymagać analizy kontekstowej.",
  centreDistance = "Umiarkowana liczba wartości odstających, niewielka skośność – transformacja opcjonalna.",
  schoolDistance = "Wysoka liczba wartości odstających i bardzo silna skośność prawostronna – konieczna transformacja.",
  poiCount = "Duża liczba wartości odstających i silna skośność prawostronna – transformacja logarytmiczna.",
  clinicDistance = "	Duża liczba wartości odstających i umiarkowana skośność prawostronna – warto zastosować transformację.",
  postOfficeDistance = "Duża liczba wartości odstających i wysoka skośność – transformacja zalecana.",
  kindergartenDistance = "Bardzo silna skośność i duża liczba wartości odstających – konieczna transformacja.",
  restaurantDistance = "Wysoka liczba wartości odstających i mocna skośność prawostronna – transformacja logarytmiczna.",
  collegeDistance = "Umiarkowana liczba wartości odstających, niewielka skośność – opcjonalna transformacja.",
  pharmacyDistance = "Silna skośność prawostronna i liczne wartości odstające – transformacja logarytmiczna.",
  pricePerSquareMeter = "Brak potrzeby transformacji ze względu na małą liczbę odstających i niewielką skośność.",
  buildingAge = "Umiarkowana liczba wartości odstających, stosunkowo niewielka skośność – opcjonalna transformacja."
)

results_table$Interpretacja <- Interpretacje[variable_names]

knitr::kable(results_table, caption = "Wyniki Z-Score oraz skośności")

```

### **Podsumowanie**:

-   **Transformacje logarytmiczne:** dla zmiennych o dużej liczbie wartości odstających i wysokiej skośności prawostronnej (poiCount, schoolDistance, clinicDistance, postOfficeDistance).
-   **Transformacje pierwiastkowe:** dla zmiennych z umiarkowaną asymetrią, ale dużą liczbą wartości odstających (squareMeters, floorCount).
-   **Transformacje opcjonalne:** dla zmiennych o umiarkowanej liczbie wartości odstających i niewielkiej skośności (collegeDistance, buildingAge).
-   **Brak transformacji:** dla zmiennych o minimalnej liczbie wartości odstających i małej skośności (pricePerSquareMeter, rooms).

```{r dodanie_nowych_danych, eval=TRUE, echo=FALSE}
# Wczytanie granic admistracyjnych województw
gml_file <- "ms_A01_Granice_wojewodztw.gml"

# Wczytanie danych przestrzennych
wojewodztwa <- st_read(gml_file)

# Tworzenie punktów z danych (longitude i latitude)
punkty <- st_as_sf(dane, coords = c("longitude", "latitude"), crs = 4326)

# Dopasowanie układu współrzędnych punktów do układu pliku GML
punkty <- st_transform(punkty, st_crs(wojewodztwa))

# Dopasowanie punktów do granic województw
dane_with_region <- st_join(punkty, wojewodztwa)

# Dodanie kolumny 'wojewodztwo' na podstawie JPT_NAZWA_
dane$wojewodztwo <- dane_with_region$JPT_NAZWA_

# Sprawdzenie wyników
#head(dane$wojewodztwo)

# Obliczenie średniej ceny za metr kwadratowy na województwo
srednie_ceny_m2 <- dane %>%
  group_by(wojewodztwo) %>%
  summarise(srednia_cena_m2 = mean(pricePerSquareMeter, na.rm = TRUE))

# Połączenie danych o cenach z granicami województw
wojewodztwa <- wojewodztwa %>%
  left_join(srednie_ceny_m2, by = c("JPT_NAZWA_" = "wojewodztwo"))

# Obliczenie centroidów województw dla etykiet
wojewodztwa_centroidy <- wojewodztwa %>%
  st_centroid() %>%
  mutate(label = JPT_NAZWA_)
```

```{r wykres_choropleth}
# Tworzenie mapy choropleth
ggplot(data = wojewodztwa) +
  geom_sf(aes(fill = srednia_cena_m2), color = "black", size = 0.2) +
  scale_fill_gradient(name = "Śr. cena za m² (PLN)", 
                      low = "white", high = "red", na.value = "gray",
                      labels = label_number(big.mark = " ", decimal.mark = ",")) +
  geom_sf_text(data = wojewodztwa_centroidy, aes(label = label), size = 3, color = "black") +
  theme_minimal() +
  labs(title = "Średnia cena za m² w Polsce według województw",
       caption = "Źródło: https://www.geoportal.gov.pl/") +
  theme(legend.position = "right")
```
